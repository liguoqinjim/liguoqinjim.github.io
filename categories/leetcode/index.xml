<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Liguoqinjim&#39;s Blog</title>
    <link>https://liguoqinjim.com/categories/leetcode/</link>
    <description>Recent content in Leetcode on Liguoqinjim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Tue, 24 Jul 2018 11:46:25 +0800</lastBuildDate>
    
	<atom:link href="https://liguoqinjim.com/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode-0008-String to Integer (atoi)</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0008/</link>
      <pubDate>Tue, 24 Jul 2018 11:46:25 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0008/</guid>
      <description>题目 Implement atoi which converts a string to an integer.
就是字符串转换为数字，但是还是有一些特殊的规则，具体看题目描述页
解法 解法1 func myAtoi(str string) int { if len(str) == 0 { return 0 } result := 0 u := -1 //有无符号 	e := -1 //错误位第几位 	for n, v := range str { if v &amp;lt; 48 || v &amp;gt; 57 { if v == 43 || v == 45 { //+-号 	if result != 0 { e = n break } if u &amp;gt;= 0 { return 0 } u = n continue } if v == 32 { //空格 	if result !</description>
    </item>
    
    <item>
      <title>LeetCode-0020-Valid Parentheses</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0020/</link>
      <pubDate>Mon, 23 Jul 2018 14:01:09 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0020/</guid>
      <description>题目 Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid.
就是要判断括号的顺序是否是正确的。
解法 解法1 func isValid(s string) bool { //这个解法用到了acsii值 	if len(s) == 0 { return true } left := make([]int, 1) left[0] = int(s[0]) for i := 1; i &amp;lt; len(s); i++ { a := int(s[i]) if len(left) == 0 { left = append(left, a) continue } if a-left[len(left)-1] !</description>
    </item>
    
    <item>
      <title>LeetCode-0014-Longest Common Prefix</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0014/</link>
      <pubDate>Sun, 22 Jul 2018 15:07:56 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0014/</guid>
      <description>题目 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.
在一组给出的字符串里面，找出最长的相同前缀。如果没有相同的前缀，返回&amp;rdquo;&amp;rdquo;
解法 解法1 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;#34;&amp;#34; } if len(strs) == 1 { return strs[0] } n := 0 end := false for !end { for i := 0; i &amp;lt; len(strs)-1; i++ { if n == len(strs[i]) || n == len(strs[i+1]) { end = true break } if strs[i][n] !</description>
    </item>
    
    <item>
      <title>LeetCode-0035-Search Insert Position</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0035/</link>
      <pubDate>Sat, 21 Jul 2018 23:56:08 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0035/</guid>
      <description>题目 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
就是有一组有序的数组和一个目标数字，如果目标数字存在在数组里面，就返回数组下标。如果不存在，则返回把目标数字按大小排列在数组里面的下标。
解法 解法1 func searchInsert(nums []int, target int) int { for n, v := range nums { if target &amp;lt;= v { return n } } return len(nums) } 解法2 func searchInsert2(nums []int, target int) int { low, high := 0, len(nums)-1 for low &amp;lt;= high { mid := (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] &amp;gt; target { high = mid - 1 } else { low = mid + 1 } } return low } 总结  解法2用到了二分法，时间复杂度是logn。在计算时间复杂度的时候，可以把high认为是一个常数，那么只有low在变化。  源代码 https://github.</description>
    </item>
    
    <item>
      <title>LeetCode-0007-Reverse Integer</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0007/</link>
      <pubDate>Fri, 20 Jul 2018 14:10:48 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0007/</guid>
      <description>题目 Given a 32-bit signed integer, reverse digits of an integer.
也就是要反转一个数字，比如123变成321、-123变成-321。但是有一个要注意的地方，数字一定要在32位的有符号数字范围内，要是不在范围内的话，返回0
解法 解法1 func reverse(x int) int { if x &amp;gt;= math.MaxInt32 || x &amp;lt;= math.MinInt32 { return 0 } i := 10 num := make([]int, 0) for { rem := x % i num = append(num, rem/(i/10)) if rem == x { break } i *= 10 } result := 0 for n, v := range num { result += v * int(math.</description>
    </item>
    
    <item>
      <title>LeetCode-0001-Two Sum</title>
      <link>https://liguoqinjim.com/post/leetcode/lab0001/</link>
      <pubDate>Thu, 19 Jul 2018 15:07:59 +0800</pubDate>
      
      <guid>https://liguoqinjim.com/post/leetcode/lab0001/</guid>
      <description>题目 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  解法 解法1 func twoSum(nums []int, target int) []int { as := make([]int, 2) for i := 0; i &amp;lt; len(nums); i++ { for j := i + 1; j &amp;lt; len(nums); j++ { if nums[i]+nums[j] == target { as[0] = i as[1] = j } } } return as } 解法2 func twoSum2(nums []int, target int) []int { r := make([]int, 2) result := make(map[int]int) //key是nums的值,value是值对应的下标 	for n, v := range nums { if value, ok := result[target-v]; ok { r[0] = value r[1] = n break } result[v] = n } return r } 总结 解法1就是最简单的循环相加，时间复杂度是O(n^2)。解法2的话因为题目里面是假设了肯定是有解的，那么就直接用一个循环来完成，时间复杂度使用O(n)</description>
    </item>
    
  </channel>
</rss>